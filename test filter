import os
import csv
import tkinter as tk
from tkinter import filedialog
from datetime import datetime, timedelta

def browse_files():
    files = filedialog.askopenfilenames(filetypes=[("CSV files", "*.csv")])
    return list(files)

def browse_folder():
    folder = filedialog.askdirectory()
    return folder

def add_one_year(date):
    try:
        return date.replace(year=date.year + 1)
    except ValueError:
        return date.replace(year=date.year + 1, day=28)

def calculate_declaration_status_and_reminders(creation_date):
    today = datetime.today()
    
    try:
        # Parse `creation_date` with time or without based on format
        if " " in creation_date:
            creation_date_dt = datetime.strptime(creation_date.strip(), "%d/%m/%Y %H:%M")
        else:
            creation_date_dt = datetime.strptime(creation_date.strip(), "%d/%m/%Y")
    except ValueError:
        # If there's an issue parsing the date, label as needing an invite
        return "Invitar a declarar"
    
    # Calculate the expiration date (one year after creation_date)
    next_due_date = add_one_year(creation_date_dt)
    days_to_expiry = (next_due_date - today).days
    
    # Determine status based on days to expiry
    if days_to_expiry < 0:
        return "Mandar reminder"  # Already expired
    elif 0 <= days_to_expiry <= 30:
        return "Mandar reminder"  # Expiring within 1 month
    else:
        # Calculate months and days to expiry
        months_to_expiry = (next_due_date.year - today.year) * 12 + (next_due_date.month - today.month)
        if next_due_date.day < today.day:
            months_to_expiry -= 1

        remaining_days = (next_due_date - (today + timedelta(days=30 * months_to_expiry))).days
        
        return f"Expira en {months_to_expiry} mes{'es' if months_to_expiry > 1 else ''} y {remaining_days} día{'s' if remaining_days != 1 else ''}"

def process_ecoi(files, folder):
    ecoi_data = []

    for file in files:
        if file.endswith('.csv'):
            with open(file, newline='') as csv_file:
                reader = csv.DictReader(csv_file)
                
                for row in reader:
                    creation_date = row.get('creation_date', '').strip()
                    
                    # Filter out rows that are not from 2023
                    if not creation_date or not creation_date.startswith('2023'):
                        continue
                    
                    try:
                        # Handle both date formats with or without time
                        if " " in creation_date:
                            creation_date_dt = datetime.strptime(creation_date, "%d/%m/%Y %H:%M")
                        else:
                            creation_date_dt = datetime.strptime(creation_date, "%d/%m/%Y")
                    except ValueError:
                        continue
                    
                    # Only include declarations made in 2023
                    if creation_date_dt.year == 2023:
                        # Calculate "Debe" status
                        debe_status = calculate_declaration_status_and_reminders(creation_date)
                        
                        # Append relevant data to ecoi_data
                        ecoi_data.append({
                            'Debe': debe_status,
                            'employee_name': row.get('employee_name', '').strip(),
                            'employee_email': row.get('employee_email', '').strip(),
                            'country': row.get('country', '').strip(),
                            'region': row.get('region', '').strip(),
                            'reminder_counter': row.get('reminder_counter', '').strip(),
                            'last_reminder': row.get('last_reminder', '').strip(),
                            'declaration_short_uid': row.get('declaration_short_uid', '').strip(),
                            'declaration_full_uid': row.get('declaration_full_uid', '').strip(),
                            'positive_answers': row.get('positive_answers', '').strip(),
                            'declaration_status': row.get('declaration_status', '').strip().lower(),
                            'declaration_expired': row.get('declaration_expired', '').strip().lower(),
                            'latest_declaration': row.get('latest_declaration', '').strip(),
                            'classification': row.get('classification', '').strip(),
                            'creation_date': creation_date,
                            'last_change_date': row.get('last_change_date', '').strip(),
                            'changed_by': row.get('changed_by', '').strip(),
                            'language': row.get('language', '').strip(),
                            'job_function': row.get('job_function', '').strip(),
                            'work_location': row.get('work_location', '').strip(),
                            'bg': row.get('bg', '').strip(),
                            'division': row.get('division', '').strip(),
                            'bau': row.get('bau', '').strip(),
                            'employee_status': row.get('employee_status', '').strip()
                        })

    with open(os.path.join(folder, 'ecoi_resultados.csv'), 'w', newline='') as results_file:
        writer = csv.writer(results_file)
        writer.writerow([
            'Debe', 'employee_name', 'employee_email', 'country', 'region', 'reminder_counter', 'last_reminder',
            'declaration_short_uid', 'declaration_full_uid', 'positive_answers', 'declaration_status', 
            'declaration_expired', 'latest_declaration', 'classification', 'creation_date', 'last_change_date',
            'changed_by', 'language', 'job_function', 'work_location', 'bg', 'division', 'bau', 'employee_status'
        ])
        
        for record in ecoi_data:
            writer.writerow([
                record['Debe'], record['employee_name'], record['employee_email'], record['country'], record['region'],
                record['reminder_counter'], record['last_reminder'], record['declaration_short_uid'],
                record['declaration_full_uid'], record['positive_answers'], record['declaration_status'],
                record['declaration_expired'], record['latest_declaration'], record['classification'], 
                record['creation_date'], record['last_change_date'], record['changed_by'], record['language'], 
                record['job_function'], record['work_location'], record['bg'], record['division'], 
                record['bau'], record['employee_status']
            ])

def button_ecoi_clicked():
    search_label.config(text="Iniciando procesamiento de ECOI...")
    files = browse_files()
    folder = browse_folder()
    process_ecoi(files, folder)
    search_label.config(text='Procesamiento de ECOI completado. Resultados guardados en ecoi_resultados.csv')

def search():
    window = tk.Toplevel(root)
    window.title("Opciones")
    window.geometry('350x150')
    window.configure(bg="#F1F1F1")
    
    option_label = tk.Label(window, text='Seleccione una opción:', font=('Helvetica', 14), bg="#F1F1F1", fg="#333")
    option_label.pack(pady=10)
    
    button_ecoi = tk.Button(window, text="Procesar ECOI", command=button_ecoi_clicked, 
                            font=('Helvetica', 12, 'bold'), bg="#FF6C63", fg="white", 
                            activebackground="#983B3B", activeforeground="white", padx=10, pady=5,
                            bd=0, relief="flat")
    button_ecoi.pack(pady=10)

root = tk.Tk()
root.title('ECOI Tracking')
root.geometry('400x300')
root.configure(bg="#2C3E50")

title_label = tk.Label(root, text="Seguimiento de ECOI", font=('Helvetica', 18, 'bold'), bg="#2C3E50", fg="white")
title_label.pack(pady=20)

search_label = tk.Label(root, text='', bg="#2C3E50", fg="white")
search_label.pack()

search_button = tk.Button(root, text='Iniciar procesamiento', command=search, 
                          font=('Helvetica', 14), bg="#3498DB", fg="white", 
                          activebackground="#2980B9", activeforeground="white", padx=10, pady=10,
                          bd=0, relief="flat")
search_button.pack(pady=20)

root.mainloop()
